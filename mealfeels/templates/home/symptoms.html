{% extends 'base.html' %}

{% block header %}
  <h3>{% block title %}Symptom Overview: {{ phone_number }}{% endblock %}</h3>
{% endblock %}

{% block content %}
<div id="symptom-chart">
</div>
{% endblock %}

{% block footer %}
<script src="https://cdn.jsdelivr.net/npm/echarts@5.6.0/dist/echarts.min.js"></script>
<script>
function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}

var symptoms = JSON.parse('{{ symptoms | tojson | safe }}');
var meals = JSON.parse('{{ meals | tojson | safe }}');

var chartData = {};

for (const [symptomBatch, occurredAt] of symptoms) {
  for (const [symptomName, magnitude] of Object.entries(symptomBatch)) {
    if (!(symptomName in chartData)) {
      chartData[symptomName] = [];
    }

    chartData[symptomName].push([new Date(occurredAt), magnitude]);
  }
}

var series = [];
for (const [symptom, magnitudes] of Object.entries(chartData)) {
  series.push({
    name: symptom,
    type: 'line',
    smooth: true,
    data: magnitudes
  });
}

var mealLines = [];
for (const [index, [meal, createdAtMillis]] of meals.entries()) {
  mealLines.push({
    xAxis: new Date(createdAtMillis),
    name: meal,
  })
}
series.push({
  name: 'meals',
  type: 'bar',
  markLine: {
    data: mealLines,
    label: {
      formatter: '{b}'
    }
  }
});

var myChart = echarts.init(document.getElementById('symptom-chart'));

var option = {
  tooltip: {
    trigger: 'axis'
  },
  legend: {
    data: chartData.keys
  },
  xAxis: {
    type: 'time',
  },
  yAxis: {
    type: 'value',
  },
  series: series,
  dataZoom: [
    {
      type: 'slider',
      <!-- zoomOnMouseWheel: 'ctrl' -->
    }
 ],
};

// Display the chart using the configuration items and data just specified.
myChart.setOption(option);

/*
function multilineLabel(createdAtMillis, string, maxWidth) {
  var createdAtTime = new Date(createdAtMillis).toLocaleTimeString().replace(/(.*)\D\d+/, '$1');
  var words = string.split(" ")

  var width = 0;
  var brokenString = ["(" + createdAtTime + ")", ""];
  for(var i = 0; i < words.length; i++) {
    var word = words[i]

    if (width + word.length + 1 >= maxWidth) {
      brokenString.push(word);
      width = word.length;
    } else {
      brokenString[brokenString.length - 1] += " " + word;
      width += word.length + 1;
    }

  }

  return brokenString;
}

const ctx = document.getElementById('myChart');

var symptoms = JSON.parse('{{ symptoms | tojson | safe }}');

var chartData = {};

for (const [symptomBatch, occurredAt] of symptoms) {
  for (const [symptomName, magnitude] of Object.entries(symptomBatch)) {
    if (!(symptomName in chartData)) {
      chartData[symptomName] = [];
    }

    chartData[symptomName].push({"y": magnitude, "x": occurredAt});
  }
}

var labeledChartData = [];
for (const [symptom, magnitudes] of Object.entries(chartData)) {
  var color = getRandomColor()
  labeledChartData.push({
    label: 'hi',
    data: magnitudes,
    borderWidth: 1,
    backgroundColor: color,
    borderColor: color
  });
}

var meals = JSON.parse('{{ meals | tojson | safe }}');

var annotations = {};
for (const [index, [meal, createdAtMillis]] of meals.entries()) {
  annotations[index] = {
    type: 'line',
    scaleID: 'x',
    value: createdAtMillis,
    backgroundColor: '#000',
    width: '5',
    borderColor: 'rgba(0,0,0,0.5)',
    borderWidth: 2,
    borderDash: [4, 5],
    label: {
      content: multilineLabel(createdAtMillis, meal, 50),
      display: false,
      color: "#fff",
      position: 'start',
    }
  };
}

new Chart(ctx, {
  type: 'line',
  data: {
    datasets: labeledChartData
  },
  options: {
    scales: {
      x: {
        type: 'time'
      },
      y: {
        suggestedMax: 10,
        beginAtZero: true
      }
    },
    plugins: {
      annotation: {
        annotations: annotations,
        enter({ element }, event) {
            element.label.options.display = true;
            return true; // force update
        },
        leave({ element }, event) {
            element.label.options.display = false;
        }
      },
      zoom: {
        pan: {
          enabled: true,
          mode: 'x',
        },
        zoom: {
          wheel: {
            enabled: true
          },
          pinch: {
            enabled: true
          },
          mode: 'x'
        }
      }
    }
  }
});
*/
</script>
{% endblock %}
